#!/usr/bin/env bash
set -euo pipefail
IFS=$'\n\t'

PROG="pathseq-t2t"
VERSION="0.1.1"

# Load libs if present
SCRIPT_DIR="$(cd -- "$(dirname -- "${BASH_SOURCE[0]}")" && pwd)"
LIB_DIR="${SCRIPT_DIR%/src}/lib"
[ -f "${LIB_DIR}/logging.sh" ] && . "${LIB_DIR}/logging.sh"
[ -f "${LIB_DIR}/utils.sh" ] && . "${LIB_DIR}/utils.sh"

# Default output directory (user can override with --outdir)
OUTDIR="${OUTDIR:-./pst2t_output}"

# Subdirs
OUTDIR_FILTER="${OUTDIR}/filter_stats"
OUTDIR_BAMS="${OUTDIR}/bams"
OUTDIR_RESULTS="${OUTDIR}/results"

usage() {
  cat <<EOF
${PROG} ${VERSION}

Usage:
  ${PROG} <command> [options]

Commands:
  prefilter   --input-bam <bam> --aligner <bwa|dragen> [--regions-to-exclude <bed>] \\
              --unaligned-out <bam> --excluded-out <bam>
  qcfilter    --input-unaligned <bam> --input-excluded <bam> \\
              --paired-out <bam> --unpaired-out <bam>
  t2tfilter   --input-paired <bam> --input-unpaired <bam> --reference <t2t.fa> \\
              --output-paired <bam> --output-unpaired <bam>
  classify    --input-paired <bam> --input-unpaired <bam> [--classifier kraken|metaphlan|both]

Global options:
  --outdir DIR    Base output directory (default: ./pst2t_output)
  -q, --quiet     Reduce logging
  -v, --verbose   Increase logging (repeatable)
  -h, --help      Show this help
  --version       Print version

Examples:
  ${PROG} prefilter --input-bam input.bam --aligner bwa --regions-to-exclude pathseq-t2t/non_human_decoys.bed
  ${PROG} qcfilter --input-unaligned pst2t_output/bams/input.unaligned.bam \\
                   --input-excluded pst2t_output/bams/input.excluded.bam
  ${PROG} t2tfilter --input-paired pst2t_output/bams/input.qcfilt_paired.bam \\
                    --input-unpaired pst2t_output/bams/input.qcfilt_unpaired.bam \\
                    --reference t2t.fa
  ${PROG} classify --input-paired pst2t_output/bams/input.t2tfilt_paired.bam \\
                   --input-unpaired pst2t_output/bams/input.t2tfilt_unpaired.bam \\
                   --classifier both
EOF
}

# --- Global flag handling ---
while [[ $# -gt 0 ]]; do
  case "$1" in
    --outdir) OUTDIR="${2:-}"; shift 2 ;;
    -q|--quiet)   log_level=0; shift ;;
    -v|--verbose) log_level=$(( ${log_level:-1} + 1 )); shift ;;
    -h|--help)    usage; exit 0 ;;
    --version)    echo "${PROG} ${VERSION}"; exit 0 ;;
    --) shift; break ;;
    -*)
      die "Unknown global option: $1"
      ;;
    *) break ;;
  esac
done

# Recompute subdirs after OUTDIR change
OUTDIR_FILTER="${OUTDIR}/filter_stats"
OUTDIR_BAMS="${OUTDIR}/bams"
OUTDIR_RESULTS="${OUTDIR}/results"
mkdir -p "${OUTDIR_FILTER}" "${OUTDIR_BAMS}" "${OUTDIR_RESULTS}"

cmd="${1:-}"
[[ -z "${cmd}" ]] && { usage; exit 2; }
shift || true

# ---------------------------- helpers ----------------------------
_semver_ge() { # usage: _semver_ge MIN ACTUAL
  # returns 0 if ACTUAL >= MIN
  printf '%s\n' "$1" "$2" | sort -V | tail -n1 | grep -qx "$2"
}

_require_samtools_116() {
  local smver
  smver=$(samtools --version 2>/dev/null | head -n1 | awk '{print $2}')
  [[ -n "${smver:-}" ]] || die "samtools not found on PATH."
  _semver_ge "1.16.0" "$smver" || die "samtools >=1.16 required (found $smver). Please upgrade."
}

_parse_first_version() { # print first x.y[.z] from stdin
  grep -Eo '[0-9]+(\.[0-9]+){1,3}' | head -n1
}

# Returns 0 if GATK >= 4 is found; prints the detected version to stdout.
_require_gatk4() {
  if ! command -v gatk >/dev/null 2>&1; then
    die "GATK not found on PATH (need gatk >= 4)."
  fi

  # Avoid set -e/pipefail breaking on non-zero; capture both stdout & stderr.
  local ver_line
  ver_line="$(( gatk --version 2>&1 || true ) | head -n1)"

  # Fallbacks: some builds put version in --help output.
  if [[ -z "$ver_line" ]]; then
    ver_line="$(( gatk --help 2>&1 || true ) | head -n3 | tr -d '\r')"
  fi

  # Extract a semantic version like 4.3.0.0
  local ver
  ver="$(grep -Eo '([0-9]+\.){1,3}[0-9]+' <<<"$ver_line" | head -n1)"

  if [[ -z "$ver" ]]; then
    die "Could not determine GATK version. Probe output: ${ver_line:-<empty>}"
  fi

  # Compare versions (needs sort -V)
  if [[ "$(printf '%s\n' '4.0.0' "$ver" | sort -V | head -n1)" != "4.0.0" ]]; then
    die "GATK >= 4 required (found $ver)."
  fi

  log "Detected GATK version: ${ver}"

  # printf '%s\n' "$ver"
}

_require_java17() {
  local java_major
  java_major=$(java -version 2>&1 | head -n1 | sed -E 's/.*version "([0-9]+).*/\1/')
  [[ "${java_major:-0}" -eq 17 ]] || die "Java 17 required (found major ${java_major:-unknown})."
}

_require_picard() {
  if [[ -z "${PICARD_JAR}" || ! -f "${PICARD_JAR}" ]]; then
    die "--picard-jar not provided or invalid. You can download Picard from the following location:
      https://github.com/broadinstitute/picard/releases/latest
    Download the latest version and provide the path to the picard.jar file when running the script."
  fi
  # Check if the provided Picard JAR file exists
  require_file "${PICARD_JAR}"
  log "Picard found at: ${PICARD_JAR}"
}

_require_bwa() {
  if ! command -v bwa >/dev/null 2>&1; then
    die "bwa not found on PATH.

Install via conda:
  conda install -c bioconda bwa

Or build from source:
  git clone https://github.com/lh3/bwa.git
  cd bwa && make
  export PATH=\$PWD:\$PATH"
  fi

  # Capture version text without tripping 'set -e'
  local raw
  raw="$(( bwa 2>&1 || true ) | head -n5)"

  # Try to extract something like 0.7.17, 0.7.17-r1188, 0.7.17-r1198-dirty, etc.
  local ver
  ver="$(grep -Eo '[0-9]+\.[0-9]+\.[0-9]+' <<<"$raw" | head -n1)"

  if [[ -z "$ver" ]]; then
    die "Could not determine bwa version from output:
$raw"
  fi

  # Require >= 0.7.17 for stable 'bwa mem'
  if [[ "$(printf '%s\n' '0.7.17' "$ver" | sort -V | head -n1)" != "0.7.17" ]]; then
    die "bwa >= 0.7.17 required for 'bwa mem' (found $ver).

bwa reported:
$raw

Upgrade via conda:
  conda install -c bioconda bwa>=0.7.17"
  fi

  log "Detected bwa version: $ver"
}


# Ensure kraken2 executable is available (optional version log).
_require_kraken2() {
  command -v kraken2 >/dev/null 2>&1 || die "kraken2 not found on PATH."
  local kver
  kver="$(kraken2 --version 2>&1 | head -n1 | _parse_first_version || true)"
  [[ -n "$kver" ]] && log "Detected Kraken2 version: $kver"
}

# Ensure MetaPhlAn v4 executable is available and version is >= 4.0.0.
_require_metaphlan4() {
  command -v metaphlan >/dev/null 2>&1 || die "metaphlan not found on PATH."
  local mver_line mver
  mver_line="$(metaphlan --version 2>&1 | head -n1 || true)"
  mver="$(printf '%s' "$mver_line" | _parse_first_version || true)"
  [[ -n "$mver" ]] || die "Could not determine MetaPhlAn version (got: ${mver_line:-<empty>})."
  _semver_ge "4.0.0" "$mver" || die "MetaPhlAn >= 4.0.0 required (found $mver)."
  log "Detected MetaPhlAn version: $mver"
}


# Helper function to ensure the required PathSeq host directory is available
_require_hostdir() {
  # Prepare the message to be displayed
  local hostdir_message="HOSTDIR is not set or missing required files. You must specify it (contains pathseq_host.bfi & pathseq_host.fa.img).

You can download and prepare the necessary files using the following commands:

  mkdir host_dir
  gcloud storage cp gs://gatk-best-practices/pathseq/resources/pathseq_host.bfi gs://gatk-best-practices/pathseq/resources/pathseq_host.fa.img ./host_dir
  export HOSTDIR=\$PWD/host_dir

Note: The host directory requires approximately 14 GB of space."

  # Check if HOSTDIR is set
  if [[ -z "${HOSTDIR}" ]]; then
    echo "$hostdir_message"
    die "HOSTDIR is not set."
  fi

  # Check if required files are present in the specified HOSTDIR
  local bfi_file="${HOSTDIR}/pathseq_host.bfi"
  local fa_img_file="${HOSTDIR}/pathseq_host.fa.img"

  if [[ ! -f "$bfi_file" || ! -f "$fa_img_file" ]]; then
    echo "$hostdir_message"
    die "HOSTDIR is missing required files."
  fi

  log "HOSTDIR verified: ${HOSTDIR}"
}

# Resolve and validate the T2T reference FASTA.
# Usage: ref_path="$(_require_t2tref "<optional_path_from_flag>")"
_require_t2tref() {
  local ref_in="${1:-}" src="--reference"
  if [[ -z "${ref_in}" ]]; then
    ref_in="${T2TREF:-}"
    src="\$T2TREF"
  fi

  if [[ -z "${ref_in}" || ! -f "${ref_in}" ]]; then
    local MSG="No T2T reference found.
Provide a path via --reference <t2t.fa> or set \$T2TREF to the FASTA file.

You can obtain the T2T-CHM13v2.0 reference from NCBI and index it like this:

  mkdir -p t2tref && cd t2tref
  wget https://ftp.ncbi.nlm.nih.gov/genomes/all/GCF/009/914/755/GCF_009914755.1_T2T-CHM13v2.0/GCF_009914755.1_T2T-CHM13v2.0_genomic.fna.gz
  gunzip GCF_009914755.1_T2T-CHM13v2.0_genomic.fna.gz

  # Build indexes (requires bwa and samtools)
  bwa index GCF_009914755.1_T2T-CHM13v2.0_genomic.fna
  samtools faidx GCF_009914755.1_T2T-CHM13v2.0_genomic.fna

  # Use it for this pipeline
  export T2TREF=\$PWD/GCF_009914755.1_T2T-CHM13v2.0_genomic.fna

Then re-run this command."
    die "${MSG}"
  fi

  log "Using T2T reference: ${ref_in}"
}



# Require a Kraken2 database directory
# Usage: _require_kraken2db /path/to/kraken2_db
_require_kraken2db() {
  local db="$1"
  if [[ -z "${db}" ]]; then
    die "No Kraken2 DB provided (--kraken2-db)."
  fi
  if [[ ! -d "${db}" ]]; then
    die "Kraken2 DB directory not found: ${db}
See: https://benlangmead.github.io/aws-indexes/k2"
  fi

  # Kraken2 requires these core files
  for f in hash.k2d opts.k2d taxo.k2d; do
    [[ -f "${db}/${f}" ]] || die "Kraken2 DB incomplete: missing ${f} in ${db}
See: https://benlangmead.github.io/aws-indexes/k2"
  done

  log "Detected valid Kraken2 DB: ${db}"
}

# Require a MetaPhlAn4 database (Bowtie2 index basename)
# Usage: _require_metaphlan4db /path/to/mpa_index
_require_metaphlan4db() {
  local idx="$1"
  if [[ -z "${idx}" ]]; then
    die "No MetaPhlAn DB index provided (--metaphlan-index)."
  fi

  local base="${idx}"
  local missing=()
  for ext in 1.bt2 2.bt2 3.bt2 4.bt2 rev.1.bt2 rev.2.bt2; do
    [[ -f "${base}.${ext}" ]] || missing+=("${base}.${ext}")
  done

  if (( ${#missing[@]} > 0 )); then
    die "MetaPhlAn DB appears incomplete at ${base}.
Missing files:
  ${missing[*]}
See: http://cmprod1.cibio.unitn.it/biobakery4/metaphlan_databases/"
  fi

  log "Detected valid MetaPhlAn4 DB index: ${base}"
}




# Validate a BAM by sleeping briefly (to allow EOF flush), then quickcheck and a full read.
# Usage: bam_check_or_die <bam_path> [context_label]
bam_check_or_die() {
  local bam="$1"
  local label="${2:-}"
  [[ -f "$bam" ]] || die "Expected BAM missing: $bam${label:+ ($label)}"

  # Give the filesystem a moment to flush BGZF EOF blocks on network/distributed FS.
  sleep 1

  if ! samtools quickcheck "$bam" >/dev/null 2>&1; then
    die "samtools quickcheck failed: $bam${label:+ ($label)}"
  fi
  # Full read to catch hidden I/O issues (suppress output)
  if ! samtools view -c "$bam" >/dev/null 2>&1; then
    die "Failed to fully read BAM (samtools view -c): $bam${label:+ ($label)}"
  fi
  log "BAM OK: $bam${label:+ ($label)}"
}


ubam_check_or_die() {
  local bam="$1"
  local label="${2:-}"
  [[ -f "$bam" ]] || die "Expected BAM missing: $bam${label:+ ($label)}"

  sleep 1
  if ! samtools quickcheck -u "$bam" >/dev/null 2>&1; then
    die "samtools quickcheck -u failed: $bam${label:+ ($label)}"
  fi
  if ! samtools view -c "$bam" >/dev/null 2>&1; then
    die "Failed to fully read BAM (samtools view -c): $bam${label:+ ($label)}"
  fi
  log "BAM OK: $bam${label:+ ($label)}"
}


# ---------------------------- Subcommands ----------------------------

cmd_prefilter() {
  local input_bam="" regions_to_exclude="" unaligned_out="" excluded_out=""
  local aligner="" flagstat_out=""
  local threads=""
  local sample_id=""

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --input-bam)          input_bam="${2:-}"; shift 2 ;;
      --regions-to-exclude) regions_to_exclude="${2:-}"; shift 2 ;;
      --unaligned-out)      unaligned_out="${2:-}"; shift 2 ;;
      --excluded-out)       excluded_out="${2:-}"; shift 2 ;;
      --aligner)            aligner="${2:-}"; shift 2 ;;
      --flagstat-out)       flagstat_out="${2:-}"; shift 2 ;;
      --threads)            threads="${2:-}"; shift 2 ;;
      --sample-id)          sample_id="${2:-}"; shift 2 ;;
      -h|--help)
        cat <<'HLP'
Usage: pathseq-t2t prefilter \
  --input-bam <bam> \
  --aligner dragen|bwa \
  --regions-to-exclude <bed|None> \
  [--unaligned-out <bam>] [--excluded-out <bam>] \
  [--flagstat-out <tsv>] \
  [--threads <int, default: auto>] \
  [--sample-id <string>]

Notes:
- --aligner is required (dragen or bwa).
- --regions-to-exclude is required; pass 'None' to skip excluding by regions.
- Flagstat is TSV. All BAMs are validated after writing.
HLP
        return 0 ;;
      --) shift; break ;;
      -*) die "Unknown option for prefilter: $1" ;;
      *)  die "Unexpected argument to prefilter: $1" ;;
    esac
  done

  require_nonempty "${input_bam}" "--input-bam"
  require_nonempty "${aligner}" "--aligner"
  require_nonempty "${regions_to_exclude}" "--regions-to-exclude"
  require_file "${input_bam}"

  _require_samtools_116

  # Threads
  if [[ -z "${threads}" ]]; then
    if command -v nproc >/dev/null 2>&1; then
      threads="$(nproc)"
    elif [[ "$OSTYPE" == "darwin"* ]] && command -v sysctl >/dev/null 2>&1; then
      threads="$(sysctl -n hw.ncpu)"
    else
      threads="8"
    fi
  fi

  # Normalize/interpret regions; build L_ARG as an array to avoid leading-space issues
  local -a L_ARG=()
  if [[ "${regions_to_exclude,,}" == "none" ]]; then
    regions_to_exclude=""
    L_ARG=()  # no -L used
  else
    require_file "${regions_to_exclude}"
    if command -v readlink >/dev/null 2>&1; then
      local abs_rl; abs_rl="$(readlink -f "${regions_to_exclude}" 2>/dev/null || true)"
      [[ -n "$abs_rl" ]] && regions_to_exclude="$abs_rl"
    fi
    L_ARG=(-L "${regions_to_exclude}")
    # preflight: ensure -L works with this BAM
    if ! samtools view -@ 1 -b "${input_bam}" "${L_ARG[@]}" -o /dev/null 2>/dev/null; then
      die "Preflight failed: samtools could not use -L '${regions_to_exclude}' with ${input_bam}"
    fi
  fi

  # Basename / sample ID
  local base
  if [[ -n "${sample_id}" ]]; then
    base="${sample_id}"
  else
    base="$(basename "${input_bam%.bam}")"
  fi

  mkdir -p "${OUTDIR_FILTER}" "${OUTDIR_BAMS}"
  [[ -z "${unaligned_out}" ]] && unaligned_out="${OUTDIR_BAMS}/${base}.unaligned.bam"
  [[ -z "${excluded_out}"  ]] && excluded_out="${OUTDIR_BAMS}/${base}.excluded.bam"
  [[ -z "${flagstat_out}"  ]] && flagstat_out="${OUTDIR_FILTER}/${base}.flagstat.tsv"

  ensure_parent_dir "${unaligned_out}"
  ensure_parent_dir "${excluded_out}"
  ensure_parent_dir "${flagstat_out}"

  log "prefilter aligner=${aligner} threads=${threads}"
  log "  input_bam:   ${input_bam}"
  log "  outputs:     unaligned=${unaligned_out} excluded=${excluded_out}"
  log "  flagstat:    ${flagstat_out}"
  log "  regions_to_exclude: ${regions_to_exclude:-<None>}"

  log "Filtering BAM..."

  # Single-pass pipeline with tee: flagstat -> unaligned/excluded splits
  case "${aligner}" in
    dragen|DRAGEN)
      time samtools view -@ "${threads}" -b "${input_bam}" \
        | tee >(samtools flagstat --output-fmt tsv -@ "${threads}" - > "${flagstat_out}") \
        | samtools view -@ "${threads}" -bh - -f 3 \
            -U >(samtools view -@ "${threads}" -bh -F 2048 -x SA -x OQ -x MD -o "${unaligned_out}") \
            -o >(samtools view -@ "${threads}" -bh -F 2048 -x SA -x OQ -x MD \
                 "${L_ARG[@]}" -o "${excluded_out}")
      ;;
    bwa|BWA)
      time samtools view -@ "${threads}" -b "${input_bam}" \
        | tee >(samtools flagstat --output-fmt tsv -@ "${threads}" - > "${flagstat_out}") \
        | samtools view -@ "${threads}" -bh - -f 3 -e '[AS]>35' \
            -U >(samtools view -@ "${threads}" -bh -F 2048 -x SA -x OQ -x MD -o "${unaligned_out}") \
            -o >(samtools view -@ "${threads}" -bh -F 2048 -x SA -x OQ -x MD \
                 "${L_ARG[@]}" -o "${excluded_out}")
      ;;
    *) die "Invalid --aligner '${aligner}'. Use 'dragen' or 'bwa'." ;;
  esac

  log "Done."

  # Post-write validations (helper sleeps 1s before quickcheck)
  bam_check_or_die "${unaligned_out}" "prefilter: unaligned_out"
  bam_check_or_die "${excluded_out}"  "prefilter: excluded_out"
  [[ -s "${flagstat_out}" ]] || die "Flagstat TSV is empty: ${flagstat_out}"

  log "prefilter done → unaligned: ${unaligned_out}, excluded: ${excluded_out}, flagstat: ${flagstat_out}"
}


cmd_qcfilter() {
  # ---------- Defaults & arg parsing ----------
  local input_unaligned="" input_excluded="" paired_out="" unpaired_out=""
  local ram_gb="16"
  local threads=""                       # auto-detect below if not provided
  local TMPDIR_OPT="${TMPDIR:-/tmp}"     # from environment if set
  local HOSTDIR_OPT="${HOSTDIR:-}"       # from environment if set (required)
  local min_clipped_read_length="60"
  local sample_id=""                     # optional override
  local dont_overwrite=0
  local keep_intermediate=0
  local PICARD_JAR="${PICARD_JAR:-}"     # optional; else use 'picard' on PATH
  local psfilterspark_args=""            # extra args to PathSeqFilterSpark

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --input-unaligned)     input_unaligned="${2:-}"; shift 2 ;;
      --input-excluded)      input_excluded="${2:-}";  shift 2 ;;
      --paired-out)          paired_out="${2:-}";      shift 2 ;;
      --unpaired-out)        unpaired_out="${2:-}";    shift 2 ;;
      --ram-gb)              ram_gb="${2:-}";          shift 2 ;;
      --threads)             threads="${2:-}";         shift 2 ;;
      --tmpdir)              TMPDIR_OPT="${2:-}";      shift 2 ;;
      --hostdir)             HOSTDIR_OPT="${2:-}";     shift 2 ;;
      --min-clipped-read-length) min_clipped_read_length="${2:-}"; shift 2 ;;
      --sample-id)           sample_id="${2:-}";       shift 2 ;;
      --dont-overwrite)      dont_overwrite=1;         shift ;;
      --keep-intermediate)   keep_intermediate=1;      shift ;;
      --psfilterspark-args)  psfilterspark_args="${2:-}"; shift 2 ;;
      --picard-jar)          PICARD_JAR="${2:-}";      shift 2 ;;
      -h|--help)
        cat <<'HLP'
Usage: pathseq-t2t qcfilter \
  --input-unaligned <bam> \
  --input-excluded  <bam> \
  [--paired-out <bam>] [--unpaired-out <bam>] \
  [--ram-gb <int, default 16>] \
  [--threads <int, default: auto-detect>] \
  [--tmpdir <dir, default: $TMPDIR or /tmp>] \
  [--hostdir <dir, default: $HOSTDIR (required)] \
  [--min-clipped-read-length <int, default 60>] \
  [--sample-id <string>] \
  [--dont-overwrite] [--keep-intermediate] \
  [--psfilterspark-args "<extra args to PathSeqFilterSpark>"] \
  [--picard-jar </path/picard.jar>]

Notes:
- If --sample-id is not provided, it defaults to the basename of --input-unaligned.
- Outputs are written under $OUTDIR/{filter_stats,bams}.
- By default, PathSeqFilterSpark is re-run each time. Use --dont-overwrite
  to skip a step only if all expected outputs already exist.
- Validations:
    * Inputs: bam_check_or_die
    * PathSeq outputs (excluded & unaligned): pathseq_check_or_die (.sbi + quickcheck -u)
    * Merged outputs: bam_check_or_die
- Requires: samtools >=1.16, GATK >=4, Java 17.
HLP
        return 0 ;;
      --) shift; break ;;
      -*) die "Unknown option for qcfilter: $1" ;;
      *)  die "Unexpected argument to qcfilter: $1" ;;
    esac
  done

  # ---------- Validation & tool version checks ----------
  require_nonempty "${input_unaligned}" "--input-unaligned"
  require_nonempty "${input_excluded}" "--input-excluded"
  require_file "${input_unaligned}"
  require_file "${input_excluded}"

  _require_samtools_116
  _require_java17
  _require_gatk4
  _require_picard
  _require_hostdir

  # Threads auto-detect
  if [[ -z "${threads}" ]]; then
    if command -v nproc >/dev/null 2>&1; then
      threads="$(nproc)"
    elif [[ "$OSTYPE" == "darwin"* ]] && command -v sysctl >/dev/null 2>&1; then
      threads="$(sysctl -n hw.ncpu)"
    else
      threads="8"
    fi
  fi

  mkdir -p "${OUTDIR_FILTER}" "${OUTDIR_BAMS}"

  # ---------- Basenames & outputs ----------
  local base_unaligned base_excluded base_merge
  base_unaligned="$(basename "${input_unaligned%.bam}")"
  base_excluded="$(basename "${input_excluded%.bam}")"
  base_merge="${sample_id:-${base_unaligned%.unaligned}}"

  local filter_metrics_excluded="${OUTDIR_FILTER}/${base_excluded}.excluded.filter_metrics.txt"
  local filter_metrics="${OUTDIR_FILTER}/${base_unaligned}.unaligned.filter_metrics.txt"

  local bam_input_excluded="${input_excluded}"
  local bam_input_excluded_rvt="${OUTDIR_BAMS}/${base_excluded}.excluded.rvt.bam"
  local bam_paired_excluded="${OUTDIR_BAMS}/${base_excluded}.excluded.paired.bam"
  local bam_unpaired_excluded="${OUTDIR_BAMS}/${base_excluded}.excluded.unpaired.bam"

  local bam_paired_filt="${OUTDIR_BAMS}/${base_unaligned}.unaligned.paired.bam"
  local bam_unpaired_filt="${OUTDIR_BAMS}/${base_unaligned}.unaligned.unpaired.bam"

  local bam_paired_merge_default="${OUTDIR_BAMS}/${base_merge}.qcfilt_paired.bam"
  local bam_unpaired_merge_default="${OUTDIR_BAMS}/${base_merge}.qcfilt_unpaired.bam"
  local bam_paired_merge="${paired_out:-$bam_paired_merge_default}"
  local bam_unpaired_merge="${unpaired_out:-$bam_unpaired_merge_default}"

  ensure_parent_dir "${bam_paired_merge}"
  ensure_parent_dir "${bam_unpaired_merge}"

  # ---------- Failure-only cleanup of Spark parts ----------
  local PART_PAIRED_DIR="${OUTDIR_BAMS}/${base_unaligned}.qcfilt_paired.bam.parts"
  local PART_UNPAIRED_DIR="${OUTDIR_BAMS}/${base_unaligned}.qcfilt_unpaired.bam.parts"
  on_exit_qcfilter() {
    local ec=$?
    if [[ $ec -ne 0 ]]; then
      for d in "${PART_PAIRED_DIR}" "${PART_UNPAIRED_DIR}"; do
        if [[ -d "$d" ]]; then
          log "Cleaning leftover Spark parts (failure): $d"
          rm -rf "$d"
        fi
      done
    fi
  }
  trap on_exit_qcfilter EXIT

  # ---------- Pre-flight: validate input BAMs ----------
  bam_check_or_die "${input_unaligned}" "qcfilter: input_unaligned"
  bam_check_or_die "${input_excluded}"  "qcfilter: input_excluded"

  # ---------- STEP 1A. PathSeq on EXCLUDED ----------
  if [[ ${dont_overwrite} -eq 1 && -f "${filter_metrics_excluded}" && -f "${bam_paired_excluded}" && -f "${bam_unpaired_excluded}" ]]; then
    log "STEP 1A (--dont-overwrite): outputs exist, skipping excluded QC-filtering."
  else
    if [[ -f "${bam_input_excluded}" ]]; then
      log "Reverting excluded bam"
      if [[ -n "${PICARD_JAR}" ]]; then
        java -jar "${PICARD_JAR}" RevertSam \
          --INPUT "${bam_input_excluded}" \
          --OUTPUT "${bam_input_excluded_rvt}" \
          --REMOVE_DUPLICATE_INFORMATION false \
          --RESTORE_ORIGINAL_QUALITIES false \
          --VERBOSITY ERROR
      else
        picard RevertSam \
          --INPUT "${bam_input_excluded}" \
          --OUTPUT "${bam_input_excluded_rvt}" \
          --REMOVE_DUPLICATE_INFORMATION false \
          --RESTORE_ORIGINAL_QUALITIES false \
          --VERBOSITY ERROR
      fi
      [[ -f "${bam_input_excluded_rvt}" ]] || die "RevertSam failed for excluded BAM."

      log "Running QC-filtering on excluded reads"
      time gatk --java-options "-Xmx${ram_gb}G" PathSeqFilterSpark \
        --input "${bam_input_excluded_rvt}" \
        --tmp-dir "${TMPDIR_OPT}" \
        --spark-master "local[${threads}]" \
        --bam-partition-size 0 \
        --is-host-aligned true \
        --kmer-file "${HOSTDIR_OPT}/pathseq_host.bfi" \
        --filter-bwa-image "${HOSTDIR_OPT}/pathseq_host.fa.img" \
        --min-clipped-read-length "${min_clipped_read_length}" \
        --filter-metrics "${filter_metrics_excluded}" \
        --paired-output "${bam_paired_excluded}" \
        --unpaired-output "${bam_unpaired_excluded}" \
        ${psfilterspark_args}

      [[ -f "${filter_metrics_excluded}" ]] || die "Excluded PathSeqFilterSpark failed (no metrics)."

      # Validate PathSeq outputs ONLY if their .sbi exists (i.e., tool wrote them)
      if [[ -f "${bam_paired_excluded}.sbi" ]]; then
        qcfilt_bam_check_or_die "${bam_paired_excluded}" "qcfilter: excluded paired"
      fi
      if [[ -f "${bam_unpaired_excluded}.sbi" ]]; then
        qcfilt_bam_check_or_die "${bam_unpaired_excluded}" "qcfilter: excluded unpaired"
      fi
    else
      log "No excluded BAM provided; skipping STEP 1A."
    fi
  fi

  # ---------- STEP 1B. PathSeq on UNALIGNED ----------
  for d in "${PART_PAIRED_DIR}" "${PART_UNPAIRED_DIR}"; do
    if [[ -d "$d" ]]; then
      log "Removing stale Spark parts from previous run: $d"
      rm -rf "$d"
    fi
  done

  if [[ ${dont_overwrite} -eq 1 && -f "${bam_paired_filt}" && -f "${bam_unpaired_filt}" ]]; then
    log "STEP 1B (--dont-overwrite): outputs exist, skipping unaligned QC-filtering."
  else
    log "Running QC-filtering on unaligned reads"
    time gatk --java-options "-Xmx${ram_gb}G" PathSeqFilterSpark \
      --input "${input_unaligned}" \
      --tmp-dir "${TMPDIR_OPT}" \
      --bam-partition-size 4000000 \
      --is-host-aligned true \
      --kmer-file "${HOSTDIR_OPT}/pathseq_host.bfi" \
      --filter-bwa-image "${HOSTDIR_OPT}/pathseq_host.fa.img" \
      --min-clipped-read-length "${min_clipped_read_length}" \
      --filter-metrics "${filter_metrics}" \
      --paired-output "${bam_paired_filt}" \
      --unpaired-output "${bam_unpaired_filt}" \
      ${psfilterspark_args}

    if [[ -f "${bam_paired_filt}.sbi" ]]; then
      ubam_check_or_die "${bam_paired_filt}"   "qcfilter: unaligned paired"
    else
      die "Expected qcfilter output missing .sbi: ${bam_paired_filt}.sbi"
    fi

    if [[ -f "${bam_unpaired_filt}.sbi" ]]; then
      ubam_check_or_die "${bam_unpaired_filt}" "qcfilter: unaligned unpaired"
    else
      die "Expected qcfilter output missing .sbi: ${bam_unpaired_filt}.sbi"
    fi
  fi

  # ---------- STEP 1C. Merge EXCLUDED + UNALIGNED ----------
  log "Merging excluded + unaligned outputs"
  if [[ -f "${bam_paired_excluded}" && -f "${bam_paired_filt}" ]]; then
    samtools merge -@ "${threads}" "${bam_paired_merge}" "${bam_paired_filt}" "${bam_paired_excluded}"
  elif [[ ! -f "${bam_paired_excluded}" && -f "${filter_metrics_excluded}" && -f "${bam_paired_filt}" ]]; then
    cp -f "${bam_paired_filt}" "${bam_paired_merge}"
  else
    err "Paired merge: inputs incomplete (paired_filt=${bam_paired_filt}; paired_excluded=${bam_paired_excluded})"
  fi

  if [[ -f "${bam_unpaired_excluded}" && -f "${bam_unpaired_filt}" ]]; then
    samtools merge -@ "${threads}" "${bam_unpaired_merge}" "${bam_unpaired_filt}" "${bam_unpaired_excluded}"
  elif [[ ! -f "${bam_unpaired_excluded}" && -f "${filter_metrics_excluded}" && -f "${bam_unpaired_filt}" ]]; then
    cp -f "${bam_unpaired_filt}" "${bam_unpaired_merge}"
  else
    err "Unpaired merge: inputs incomplete (unpaired_filt=${bam_unpaired_filt}; unpaired_excluded=${bam_unpaired_excluded})"
  fi

  # Validate merged outputs (merged BAMs won’t have .sbi; use generic check)
  ubam_check_or_die "${bam_paired_merge}"   "qcfilter: merged paired"
  ubam_check_or_die "${bam_unpaired_merge}" "qcfilter: merged unpaired"

  # ---------- Post-success cleanup ----------
  if [[ ${keep_intermediate} -eq 0 ]]; then
    log "Removing intermediate outputs (use --keep-intermediate to retain):"
    for f in \
      "${bam_input_excluded_rvt}" \
      "${bam_paired_excluded}" \
      "${bam_unpaired_excluded}" \
      "${bam_paired_filt}" \
      "${bam_paired_filt}.sbi" \
      "${bam_unpaired_filt}" \
      "${bam_unpaired_filt}.sbi"
    do
      [[ -e "$f" ]] && rm -f "$f"
    done
  fi

  log "qcfilter done → paired: ${bam_paired_merge} ; unpaired: ${bam_unpaired_merge}"
}


cmd_t2tfilter() {
  local input_paired="" input_unpaired="" reference=""
  local output_paired="" output_unpaired=""
  local threads=""
  local sample_id=""
  local dont_overwrite=0
  local keep_intermediate=0
  local PICARD_JAR="${PICARD_JAR:-}"

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --input-paired)       input_paired="${2:-}"; shift 2 ;;
      --input-unpaired)     input_unpaired="${2:-}"; shift 2 ;;
      --reference)          reference="${2:-}"; shift 2 ;;
      --output-paired)      output_paired="${2:-}"; shift 2 ;;
      --output-unpaired)    output_unpaired="${2:-}"; shift 2 ;;
      --threads)            threads="${2:-}"; shift 2 ;;
      --sample-id)          sample_id="${2:-}"; shift 2 ;;
      --dont-overwrite)     dont_overwrite=1; shift ;;
      --keep-intermediate)  keep_intermediate=1; shift ;;
      --picard-jar)         PICARD_JAR="${2:-}"; shift 2 ;;
      -h|--help)
        cat <<'HLP'
Usage: pathseq-t2t t2tfilter \
  --input-paired <bam> \
  --input-unpaired <bam> \
  [--reference <t2t.fa> | env $T2TREF] \
  [--output-paired <bam>] [--output-unpaired <bam>] \
  [--threads <int, default: auto-detect>] \
  [--sample-id <string>] \
  [--dont-overwrite] [--keep-intermediate] \
  [--picard-jar </path/picard.jar>]

Notes:
- Expects merged PathSeq outputs from qcfilter:
    <something>.qcfilt_paired.bam      (paired)
    <something>.qcfilt_unpaired.bam    (unpaired)
- --reference is optional if $T2TREF is set.
- Picard options use long-form syntax (--INPUT/--OUTPUT/etc.).
- FASTQ intermediates use separate basenames per input BAM.
- Final outputs:
    <base>.t2tfilt_paired.bam
    <base>.t2tfilt_unpaired.bam
- Flagstats are written as TSV.
- Requires: samtools >=1.16, Java 17, and bwa in PATH.
HLP
        return 0 ;;
      --) shift; break ;;
      -*) die "Unknown option for t2tfilter: $1" ;;
      *)  die "Unexpected argument to t2tfilter: $1" ;;
    esac
  done

  # --- Required inputs ---
  require_nonempty "${input_paired}"  "--input-paired"
  require_nonempty "${input_unpaired}" "--input-unpaired"
  require_file "${input_paired}"
  require_file "${input_unpaired}"

  # --- Version / tool checks ---
  _require_samtools_116
  _require_java17
  _require_picard
  _require_bwa
  _require_t2tref

    # --- Reference handling ---
  if [[ -z "${reference}" ]]; then
    if [[ -n "${T2TREF:-}" ]]; then
      reference="${T2TREF}"
      log "Using reference from T2TREF: ${reference}"
    else
      die "No reference provided. Use --reference <t2t.fa> or set T2TREF environment variable."
    fi
  fi
  require_file "${reference}"

  # --- Validate input BAMs (helper sleeps 1s & fully reads) ---
  ubam_check_or_die "${input_paired}"   "t2tfilter: input_paired"
  ubam_check_or_die "${input_unpaired}" "t2tfilter: input_unpaired"

  # Threads autodetect
  if [[ -z "${threads}" ]]; then
    if command -v nproc >/dev/null 2>&1; then
      threads="$(nproc)"
    elif [[ "$OSTYPE" == "darwin"* ]] && command -v sysctl >/dev/null 2>&1; then
      threads="$(sysctl -n hw.ncpu)"
    else
      threads="8"
    fi
  fi

  mkdir -p "${OUTDIR_BAMS}" "${OUTDIR_FILTER}"

  # --- Basenames (separate for paired/unpaired FASTQs) ---
  local base_paired base_unpaired out_base
  base_paired="$(basename "${input_paired%.bam}")"
  base_unpaired="$(basename "${input_unpaired%.bam}")"
  out_base="${sample_id:-$base_paired}"

  # --- Outputs ---
  [[ -z "${output_paired}"   ]] && output_paired="${OUTDIR_BAMS}/${base_paired}.t2tfilt.bam"
  [[ -z "${output_unpaired}" ]] && output_unpaired="${OUTDIR_BAMS}/${base_unpaired}.t2tfilt.bam"
  ensure_parent_dir "${output_paired}"
  ensure_parent_dir "${output_unpaired}"

  # --- Intermediates & stats (TSV) ---
  local fastq_r1="${OUTDIR_BAMS}/${base_paired}.R1.fq.gz"
  local fastq_r2="${OUTDIR_BAMS}/${base_paired}.R2.fq.gz"
  local fastq_u="${OUTDIR_BAMS}/${base_unpaired}.U.fq.gz"

  local bam_aligned_paired="${OUTDIR_BAMS}/${base_paired}.t2t_aln.bam"
  local bam_aligned_unpaired="${OUTDIR_BAMS}/${base_unpaired}.t2t_aln.bam"

  local flagstat_aligned_paired="${OUTDIR_FILTER}/${base_paired}.t2t_aln.flagstat.tsv"
  local flagstat_unaligned_paired="${OUTDIR_FILTER}/${base_paired}.t2t_unaln.flagstat.tsv"
  local flagstat_aligned_unpaired="${OUTDIR_FILTER}/${base_unpaired}.t2t_aln.flagstat.tsv"
  local flagstat_unaligned_unpaired="${OUTDIR_FILTER}/${base_unpaired}.t2t_unaln.flagstat.tsv"

  # Skip whole step only if --dont-overwrite and final outputs exist
  if [[ ${dont_overwrite} -eq 1 && -f "${output_paired}" && -f "${output_unpaired}" ]]; then
    log "t2tfilter (--dont-overwrite): final outputs exist; skipping."
    return 0
  fi

  log "t2tfilter threads=${threads} sample=${out_base}"

  # --- Convert QC-filtered BAMs -> FASTQ (paired) ---
  if [[ ! -f "${fastq_r1}" || ! -f "${fastq_r2}" ]]; then
    log "Converting paired QC-filtered BAM to FASTQ"
    if [[ -n "${PICARD_JAR}" ]]; then
      java -jar "${PICARD_JAR}" SamToFastq \
        --INPUT "${input_paired}" \
        --FASTQ "${fastq_r1}" \
        --SECOND_END_FASTQ "${fastq_r2}"
    else
      picard SamToFastq \
        --INPUT "${input_paired}" \
        --FASTQ "${fastq_r1}" \
        --SECOND_END_FASTQ "${fastq_r2}"
    fi
  fi

  # --- Convert PathSeq BAM -> FASTQ (unpaired) ---
  if [[ ! -f "${fastq_u}" ]]; then
    log "Converting unpaired QC-filtered BAM to FASTQ"
    if [[ -n "${PICARD_JAR}" ]]; then
      java -jar "${PICARD_JAR}" SamToFastq \
        --INPUT "${input_unpaired}" \
        --FASTQ "${fastq_u}"
    else
      picard SamToFastq \
        --INPUT "${input_unpaired}" \
        --FASTQ "${fastq_u}"
    fi
  fi

  # --- Align paired to T2T ---
  if [[ ! -f "${bam_aligned_paired}" || ${dont_overwrite} -eq 0 ]]; then
    log "Aligning paired reads to T2T"
    bwa mem -t "${threads}" -T 0 "${reference}" "${fastq_r1}" "${fastq_r2}" \
      | samtools view -Shb -o "${bam_aligned_paired}"
    [[ -f "${bam_aligned_paired}" ]] || die "Failed to create aligned paired BAM."
  fi

  # --- Extract unaligned paired -> final output_paired ---
  if [[ ! -f "${output_paired}" || ${dont_overwrite} -eq 0 ]]; then
    log "[ Extracting paired unaligned reads ]"
    time samtools view -@ "${threads}" -bh "${bam_aligned_paired}" -f 3 -e '[AS]>35' \
      -U >(samtools view -@ "${threads}" -bh -F 2048 -x SA -x OQ -x MD -o "${output_paired}") \
      -o >(samtools flagstat --output-fmt tsv - > "${flagstat_aligned_paired}")
    samtools flagstat --output-fmt tsv "${output_paired}" > "${flagstat_unaligned_paired}" || true
  fi

  # --- Align unpaired to T2T ---
  if [[ ! -f "${bam_aligned_unpaired}" || ${dont_overwrite} -eq 0 ]]; then
    log "[ Aligning unpaired reads to T2T ]"
    bwa mem -t "${threads}" -T 0 "${reference}" "${fastq_u}" \
      | samtools view -Shb -o "${bam_aligned_unpaired}"
    [[ -f "${bam_aligned_unpaired}" ]] || die "Failed to create aligned unpaired BAM."
  fi

  # --- Extract unaligned unpaired -> final output_unpaired ---
  if [[ ! -f "${output_unpaired}" || ${dont_overwrite} -eq 0 ]]; then
    log "[ Extracting unpaired unaligned reads ]"
    time samtools view -@ "${threads}" -bh "${bam_aligned_unpaired}" -e '[AS]>35' \
      -U >(samtools view -@ "${threads}" -bh -F 2048 -x SA -x OQ -x MD -o "${output_unpaired}") \
      -o >(samtools flagstat --output-fmt tsv - > "${flagstat_aligned_unpaired}")
    samtools flagstat --output-fmt tsv "${output_unpaired}" > "${flagstat_unaligned_unpaired}" || true
  fi

  # --- Post-run integrity checks (sleep + full read via helper) ---
  bam_check_or_die "${output_paired}"   "t2tfilter: final paired"
  bam_check_or_die "${output_unpaired}" "t2tfilter: final unpaired"

  # --- Cleanup intermediates (unless requested to keep) ---
  if [[ ${keep_intermediate} -eq 0 ]]; then
    log "Removing intermediate FASTQs and aligned BAMs (use --keep-intermediate to retain):"
    for f in \
      "${fastq_r1}" "${fastq_r2}" "${fastq_u}" \
      "${bam_aligned_paired}" "${bam_aligned_unpaired}"
    do
      [[ -e "$f" ]] && rm -f "$f"
    done
  fi

  log "t2tfilter done → paired(unmapped): ${output_paired} ; unpaired(unmapped): ${output_unpaired}"
}



cmd_classify() {
  local input_paired="" input_unpaired=""
  local classifier="kraken"            # kraken | metaphlan | both
  local threads=""
  local sample_id=""
  local dont_overwrite=0
  local keep_intermediate=0
  local PICARD_JAR="${PICARD_JAR:-}"

  # DB/config (can come from env)
  local kraken_db="${KRAKEN_DB:-}"
  local metaphlan_index="${METAPHLAN_INDEX:-}"   # e.g., mpa_vJun23_CHOCOPhlAnSGB_202403
  local bowtie2db="${BOWTIE2DB:-}"

  # Extra args passthrough
  local kraken_args=""
  local metaphlan_args=""

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --input-paired)       input_paired="${2:-}"; shift 2 ;;
      --input-unpaired)     input_unpaired="${2:-}"; shift 2 ;;
      --classifier)         classifier="${2:-}"; shift 2 ;;   # kraken|metaphlan|both
      --threads)            threads="${2:-}"; shift 2 ;;
      --sample-id)          sample_id="${2:-}"; shift 2 ;;
      --dont-overwrite)     dont_overwrite=1; shift ;;
      --keep-intermediate)  keep_intermediate=1; shift ;;
      --kraken-db)          kraken_db="${2:-}"; shift 2 ;;
      --metaphlan-index)    metaphlan_index="${2:-}"; shift 2 ;;
      --bowtie2db)          bowtie2db="${2:-}"; shift 2 ;;
      --kraken-args)        kraken_args="${2:-}"; shift 2 ;;
      --metaphlan-args)     metaphlan_args="${2:-}"; shift 2 ;;
      --picard-jar)         PICARD_JAR="${2:-}"; shift 2 ;;
      -h|--help)
        cat <<'HLP'
Usage: pathseq-t2t classify \
  --input-paired <bam> \
  --input-unpaired <bam> \
  [--classifier kraken|metaphlan|both] (default: kraken) \
  [--threads <int, default: auto-detect>] \
  [--sample-id <string>] \
  [--dont-overwrite] [--keep-intermediate] \
  [--kraken-db <dir> | env $KRAKEN_DB] \
  [--metaphlan-index <name> | env $METAPHLAN_INDEX] \
  [--bowtie2db <dir> | env $BOWTIE2DB] \
  [--kraken-args "<extra args>"] \
  [--metaphlan-args "<extra args>"] \
  [--picard-jar </path/picard.jar>]

Notes:
- If --sample-id is not provided, it defaults to the basename of --input-paired.
- Outputs are written under $OUTDIR/results; intermediate FASTQs are in $OUTDIR/bams.
- Both input BAMs are validated with samtools quickcheck before classification.
- By default we remove intermediate FASTQs after success; use --keep-intermediate to retain.
- Picard options use long-form syntax (--INPUT/--FASTQ/--SECOND_END_FASTQ).
- Requires: samtools >=1.16, Java 17; kraken2/metaphlan must be present if selected.
HLP
        return 0 ;;
      --) shift; break ;;
      -*) die "Unknown option for classify: $1" ;;
      *)  die "Unexpected argument to classify: $1" ;;
    esac
  done

  require_nonempty "${input_paired}"  "--input-paired"
  require_nonempty "${input_unpaired}" "--input-unpaired"
  require_file "${input_paired}"
  require_file "${input_unpaired}"

  _require_picard

  # Tools for classifiers (checked only if used)
  local run_kraken=0 run_metaphlan=0
  case "${classifier}" in
    kraken|KRAKEN)                 run_kraken=1 ;;
    metaphlan|MetaPhlAn|METAPHLAN) run_metaphlan=1 ;;
    both|BOTH)                     run_kraken=1; run_metaphlan=1 ;;
    *) die "Invalid --classifier '${classifier}'. Use 'kraken', 'metaphlan', or 'both'." ;;
  esac

  # Conditional tool + DB checks (guard with :-0)
  if [[ ${run_kraken:-0} -eq 1 ]]; then
    _require_kraken2
    _require_kraken2db "${kraken_db:-}"
  fi

  if [[ ${run_metaphlan:-0} -eq 1 ]]; then
    _require_metaphlan4
    _require_metaphlan4db "${metaphlan_index:-}" "${bowtie2db:-}"
  fi



  # Auto threads
  if [[ -z "${threads}" ]]; then
    if command -v nproc >/dev/null 2>&1; then
      threads="$(nproc)"
    elif [[ "$OSTYPE" == "darwin"* ]] && command -v sysctl >/dev/null 2>&1; then
      threads="$(sysctl -n hw.ncpu)"
    else
      threads="8"
    fi
  fi

  mkdir -p "${OUTDIR_RESULTS}" "${OUTDIR_BAMS}" "${OUTDIR_FILTER}"

  # Sample/base naming
  local base_paired base_unpaired out_base
  base_paired="$(basename "${input_paired%.bam}")"
  base_unpaired="$(basename "${input_unpaired%.bam}")"
  if [[ -n "${sample_id}" ]]; then
    out_base="${sample_id}"
  else
    out_base="${base_paired}"
  fi

  # Validate inputs with quickcheck (no deletion on failure)
  for f in "${input_paired}" "${input_unpaired}"; do
    ubam_check_or_die $f
  done

  # Prepare FASTQ intermediates (paired + unpaired, separate basenames)
  local fastq_r1="${OUTDIR_BAMS}/${base_paired}.classify.R1.fq.gz"
  local fastq_r2="${OUTDIR_BAMS}/${base_paired}.classify.R2.fq.gz"
  local fastq_fu="${OUTDIR_BAMS}/${base_paired}.classify.FU.fq.gz"       # unpaired reads emitted from paired BAM (if any)
  local fastq_unp="${OUTDIR_BAMS}/${base_unpaired}.classify.unpaired.fq.gz"
  local fastq_mrg="${OUTDIR_BAMS}/${out_base}.metaphlan.merged.fq.gz"    # one name for merged file

  # Convert BAMs -> FASTQ (paired)
  if [[ ! -f "${fastq_r1}" || ! -f "${fastq_r2}" || ${dont_overwrite} -eq 0 ]]; then
    log "Converting unmapped paired BAM to FASTQs"
    if [[ -n "${PICARD_JAR}" ]]; then
      time java -jar "${PICARD_JAR}" SamToFastq \
        --INPUT "${input_paired}" \
        --FASTQ "${fastq_r1}" \
        --SECOND_END_FASTQ "${fastq_r2}" \
        --UNPAIRED_FASTQ "${fastq_fu}"
    else
      time picard SamToFastq \
        --INPUT "${input_paired}" \
        --FASTQ "${fastq_r1}" \
        --SECOND_END_FASTQ "${fastq_r2}" \
        --UNPAIRED_FASTQ "${fastq_fu}"
    fi
    [[ -f "${fastq_r1}" && -f "${fastq_r2}" ]] || die "Failed to create paired FASTQs."
  fi

  # Convert BAM -> FASTQ (unpaired)
  if [[ ! -f "${fastq_unp}" || ${dont_overwrite} -eq 0 ]]; then
    log "Converting unmapped unpaired BAM to FASTQ"
    if [[ -n "${PICARD_JAR}" ]]; then
      time java -jar "${PICARD_JAR}" SamToFastq \
        --INPUT "${input_unpaired}" \
        --FASTQ "${fastq_unp}"
    else
      time picard SamToFastq \
        --INPUT "${input_unpaired}" \
        --FASTQ "${fastq_unp}"
    fi
    [[ -f "${fastq_unp}" ]] || die "Failed to create unpaired FASTQ."
  fi

  # ---------- Run Kraken2 ----------
  if [[ $run_kraken -eq 1 ]]; then
    local k2_out_paired="${OUTDIR_RESULTS}/${out_base}.kraken.paired.txt"
    local k2_rep_paired="${OUTDIR_RESULTS}/${out_base}.kraken.paired.report"
    local k2_out_unpaired="${OUTDIR_RESULTS}/${out_base}.kraken.unpaired.txt"
    local k2_rep_unpaired="${OUTDIR_RESULTS}/${out_base}.kraken.unpaired.report"

    if [[ ${dont_overwrite} -eq 1 && -f "${k2_out_paired}" && -f "${k2_rep_paired}" && -f "${k2_out_unpaired}" && -f "${k2_rep_unpaired}" ]]; then
      log "classify (--dont-overwrite): Kraken outputs exist; skipping."
    else
      log "[ Classifying paired reads with Kraken2 ]"
      time kraken2 "${fastq_r1}" "${fastq_r2}" \
        --paired \
        --report-minimizer-data \
        --db "${kraken_db}" \
        --report "${k2_rep_paired}" \
        --output "${k2_out_paired}" \
        --confidence 0.15 \
        --threads "${threads}" \
        ${kraken_args}

      log "[ Classifying unpaired reads with Kraken2 ]"
      # Combine unpaired from both sources when present
      if [[ -s "${fastq_fu}" ]]; then
        time kraken2 <(zcat "${fastq_unp}" "${fastq_fu}") \
          --report-minimizer-data \
          --db "${kraken_db}" \
          --report "${k2_rep_unpaired}" \
          --output "${k2_out_unpaired}" \
          --confidence 0.15 \
          --threads "${threads}" \
          ${kraken_args}
      else
        time kraken2 "${fastq_unp}" \
          --report-minimizer-data \
          --db "${kraken_db}" \
          --report "${k2_rep_unpaired}" \
          --output "${k2_out_unpaired}" \
          --confidence 0.15 \
          --threads "${threads}" \
          ${kraken_args}
      fi
    fi
  fi

  # ---------- Run MetaPhlAn ----------
  if [[ $run_metaphlan -eq 1 ]]; then
    local mpa_out="${OUTDIR_RESULTS}/${out_base}.metaphlan.txt"
    local bowtie2out_mpa="${OUTDIR_RESULTS}/${out_base}.metaphlan.bowtie2.bz2"

    if [[ ! -f "${fastq_mrg}" || ${dont_overwrite} -eq 0 ]]; then
      log "[ Merging FASTQs for MetaPhlAn ]"
      # Merge paired + unpaired; include FU if present
      if [[ -s "${fastq_fu}" ]]; then
        zcat "${fastq_r1}" "${fastq_r2}" "${fastq_unp}" "${fastq_fu}" 2>/dev/null | gzip -c > "${fastq_mrg}"
      else
        zcat "${fastq_r1}" "${fastq_r2}" "${fastq_unp}" 2>/dev/null | gzip -c > "${fastq_mrg}"
      fi
    fi

    if [[ ${dont_overwrite} -eq 1 && -f "${mpa_out}" && -f "${bowtie2out_mpa}" ]]; then
      log "classify (--dont-overwrite): MetaPhlAn outputs exist; skipping."
    else
      log "[ Executing MetaPhlAn ]"
      time metaphlan "${fastq_mrg}" \
        --nproc "${threads}" \
        --read_min_len 60 \
        --input_type fastq \
        --index "${metaphlan_index}" \
        --bowtie2db "${bowtie2db}" \
        -t rel_ab_w_read_stats \
        --bowtie2out "${bowtie2out_mpa}" \
        ${metaphlan_args} \
        > "${mpa_out}"
    fi
  fi

  # ---------- Cleanup intermediates (default: remove) ----------
  if [[ ${keep_intermediate} -eq 0 ]]; then
    log "Removing intermediate FASTQs (use --keep-intermediate to retain):"
    for f in "${fastq_r1}" "${fastq_r2}" "${fastq_fu}" "${fastq_unp}" "${fastq_mrg}"; do
      [[ -e "$f" ]] && rm -f "$f"
    done
  fi

  log "classify done (classifier=${classifier})"
}



# ---------------------------- Dispatcher ----------------------------
case "${cmd}" in
  prefilter)   cmd_prefilter "$@" ;;
  qcfilter)    cmd_qcfilter "$@" ;;
  t2tfilter)   cmd_t2tfilter "$@" ;;
  classify)    cmd_classify "$@" ;;
  -h|--help|help) usage ;;
  *) die "Unknown command: ${cmd}. Run '${PROG} --help' for usage." ;;
esac
